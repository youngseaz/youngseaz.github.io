<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[ubuntu重置密码出现的问题]]></title>
      <url>/2018/02/23/ubuntu%E9%87%8D%E7%BD%AE%E5%AF%86%E7%A0%81%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>忘记ubuntu的密码之后，按照网上的一般方式进入recovery mode，然后选择drop to root shell prompt，但是进去之后提示Give root password for maintenance
(要输入密码,可是自己就是要通过这种方式找回密码的)，网上找了许久，发现以下方法方法有效：</p><p>
<img src="2.png" alt="">
<img src="3.png" alt="">
重启之后运行如下命令即可
<img src="1.png" alt="">
相关参考:</p><p>
<a href="https://www.youtube.com/watch?v=ThPAWo7e8LI" target="_blank" rel="noopener">https://www.youtube.com/watch?v=ThPAWo7e8LI</a></p><p>
<a href="https://help.ubuntu.com/community/LostPassword" target="_blank" rel="noopener">https://help.ubuntu.com/community/LostPassword</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[利用vps搭建ss服务器]]></title>
      <url>/2018/02/22/%E5%88%A9%E7%94%A8vps%E6%90%AD%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>参考别人的文件发现搭建一个ss（shadowsocks）服务器是很简单的，利用vps（virtual private server）就可以，此文以
<a href="https://vultr.com" target="_blank" rel="noopener"><font color="red">vultr</font></a>的vps为例:</p><p>
注册账号，然后充值（支持支付宝）<img src="1.png" alt="">
然后点击Servers，再点击图片中的加号添加服务器<img src="2.png" alt="">
<img src="3.png" alt="">
<img src="4.png" alt="">
之后就是登录服务器部署，登录之前先从server details看一看登录服务器要用到的用户名、密码以及ip地址，可以从view console登录服务器，也可以使用
<a href="https://putty.org" target="_blank" rel="noopener"><font color="red">Putty</font></a>登录
<img src="5.png" alt="">
<img src="6.png" alt="">
登录服务器之后运行以下三条命令
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</div><div class="line">chmod +x shadowsocks.sh</div><div class="line">./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</div></pre></td></tr></table></figure></p>
<p>三条命令运行成功之后，按照提示设置密码、端口和选择加密方式，成功安装之后会显示你的配置信息，之后下载客户端，输入配置信息就可以使用啦</p><p>
相关链接：</p><p>
<a href="https://shadowsocks.org/en/download/clients.html" target="_blank" rel="noopener">link for downloading shadowsocks</a></p><p>
参考：</p><p>
<a href="https://www.jianshu.com/p/1c82ee1293a4" target="_blank" rel="noopener">https://www.jianshu.com/p/1c82ee1293a4</a></p><p>
<a href="https://teddysun.com/342.html" target="_blank" rel="noopener">https://teddysun.com/342.html</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo搭建博客中出现的问题以及解决方法]]></title>
      <url>/2017/12/20/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="hexo对html的table标签不兼容"><a href="#hexo对html的table标签不兼容" class="headerlink" title="hexo对html的table标签不兼容"></a>hexo对html的table标签不兼容</h1><p>写文章时使用html的table做表格会发现文章被渲染出多个&lt;br&gt;,导致表格与其前面有很多空白的地方，十分不美观，
解决方法：<br>
在hexo目录下_config.yml添加<br>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">marked:</span></div><div class="line"><span class="attr">    gfm:</span> <span class="literal">true</span></div><div class="line"><span class="attr">    break:</span> <span class="literal">false</span></div></pre></td></tr></table></figure></p>
<p><a href="https://github.com/hexojs/hexo/issues/1388" target="blank"><font color="red">参考</font></a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[爬虫学习]]></title>
      <url>/2017/12/19/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h1 id="Python2-X和Python3-X调用urllib库常见的变化"><a href="#Python2-X和Python3-X调用urllib库常见的变化" class="headerlink" title="Python2.X和Python3.X调用urllib库常见的变化"></a>Python2.X和Python3.X调用urllib库常见的变化</h1><table>
<thead>
<tr>
<th style="text-align:center">Python2.X</th>
<th style="text-align:center">Python3.X</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">import urllib2</td>
<td style="text-align:center">import urllib.request,urllib.error</td>
</tr>
<tr>
<td style="text-align:center">import urllib</td>
<td style="text-align:center">import urllib.request,urllib.error,urllib.parse</td>
</tr>
<tr>
<td style="text-align:center">import urlparse</td>
<td style="text-align:center">import urllib.parse</td>
</tr>
<tr>
<td style="text-align:center">urllib2.open</td>
<td style="text-align:center">urllib.request.open</td>
</tr>
<tr>
<td style="text-align:center">urllib.urlencode</td>
<td style="text-align:center">urllib.parse.urlencode</td>
</tr>
<tr>
<td style="text-align:center">urllib.quote</td>
<td style="text-align:center">urllib.request.quote</td>
</tr>
<tr>
<td style="text-align:center">cookielib.CookieJar</td>
<td style="text-align:center">http.CookieJar</td>
</tr>
<tr>
<td style="text-align:center">urllib2.Request</td>
<td style="text-align:center">urllib.request.Request</td>
</tr>
</tbody>
</table>
<h1 id="修改报头"><a href="#修改报头" class="headerlink" title="修改报头"></a>修改报头</h1><p>当网站网页禁止（403 forbidden）使用Python urllib库中默认的报头(headers)，我们需要修改报头</p>
<h2 id="使用build-opener-修改报头"><a href="#使用build-opener-修改报头" class="headerlink" title="使用build_opener()修改报头"></a>使用build_opener()修改报头</h2><p>以下是实现这种方法的一段代码：
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib.request</div><div class="line">url = (<span class="string">"a url"</span>)</div><div class="line">headers = (<span class="string">"User-Agent"</span>,<span class="string">"the details of User-Agent"</span>)</div><div class="line">opener = urllib.request.build_opener()</div><div class="line">opener.addheaders = [headers]</div><div class="line">data = opener.open(url).read()</div></pre></td></tr></table></figure></p>
<h2 id="使用add-header-添加报头"><a href="#使用add-header-添加报头" class="headerlink" title="使用add_header()添加报头"></a>使用add_header()添加报头</h2><p>使用urllib.request.Request()下的add_header()修改UA。<br>
实现浏览器的模拟，
以下是实现这种方法的一段代码：
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib.request</div><div class="line">url = <span class="string">"a url"</span></div><div class="line">req = urllib.request.Request(url)</div><div class="line">req.add_header(<span class="string">"User-Agent"</span>,<span class="string">"the details of User-Agent"</span>)</div><div class="line">data = urllib.request.urlopen(req).read()</div></pre></td></tr></table></figure></p>
<h1 id="使用代理"><a href="#使用代理" class="headerlink" title="使用代理"></a>使用代理</h1><p>有时使用同一个IP爬取别人网页的东西，久了之后有可能会被该网站屏蔽这个IP，这是可以使用代理IP。
代理IP可以通过搜索引擎找到（国内高匿IP）。代码实现如下：
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_proxy</span><span class="params">(proxy_addr,url)</span>:</span>         <span class="comment">#定义一个使用代理IP的函数</span></div><div class="line">	<span class="keyword">import</span> urllib.request</div><div class="line">	proxy = urllib.request.ProxyHandler(&#123;<span class="string">'http'</span>:proxy_addr&#125;)</div><div class="line">	opener = urllib.request.build_opener(proxy,urllib.request.ProxyHandler)</div><div class="line">	urllib.request.install_opener(opener)</div><div class="line">	data = urllib.request.urlopen(url).read().decode(<span class="string">'utf-8'</span>)</div><div class="line">	<span class="keyword">return</span> data</div><div class="line">proxy_addr = <span class="string">"xxx.xxx.xxx.xxx:xx"</span>  <span class="comment">#这里赋值给proxy_addr的是代理的IP以及它的端口号</span></div><div class="line">data = use_proxy(proxy_addr,<span class="string">'http://www.baidu.com'</span>)</div><div class="line">print(len(data))</div></pre></td></tr></table></figure></p>
<p>这段代码运行成功会打印出百度首页的长度，失败的话会出现urllib.error.URLError的报错</p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p><a href="https://docs.python.org/3/library/re.html" target="_blank" rel="noopener"><font color="red">相关文档</font></a></p>
<h2 id="re-search-与re-match-的qubie"><a href="#re-search-与re-match-的qubie" class="headerlink" title="re.search()与re.match()的qubie"></a>re.search()与re.match()的qubie</h2><p>re.match()函数从源字符串的开头进行匹配，re.search()函数在全文进行检索并匹配</p><p>
例子：</p><p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line">string = <span class="string">"hellopythonmypythonhispythonourpythonPython"</span></div><div class="line">pattern = <span class="string">".python."</span></div><div class="line">result1 = re.match(pattern,string)</div><div class="line">result2 = re.search(pattern,string)</div><div class="line">print(result1)</div><div class="line">print(result2)</div><div class="line">----------------------------------------</div><div class="line"><span class="comment">#程序运行的结果为：</span></div><div class="line"><span class="keyword">None</span></div><div class="line">&lt;_sre.SRE_Match object; span(<span class="number">6</span>,<span class="number">14</span>),match=<span class="string">'ypythonh'</span>&gt;</div></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[函数与栈]]></title>
      <url>/2017/12/04/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%A0%88/</url>
      <content type="html"><![CDATA[<p>程序使用栈内存来记住函数返回的位置，每一个c程序都由栈控制其函数执行的流程。几乎所有计算机编程语言都采用这个方案。</p>
<h2 id="栈的调用规则"><a href="#栈的调用规则" class="headerlink" title="栈的调用规则"></a>栈的调用规则</h2><p>①当一个函数被调用时，这条调用之后的行编号就被压入调用栈。这个行编号就是“返回位置”（RL），这是在调用函数结束后（即返回）之后程序继续执行的地方。
②如果相同的函数在不同行被调用，那么这个调用都有一个相应的返回位置（每个函数调用之后的那行）。
③当一个函数结束之后，程序将从储存在调用栈顶部的行编号处继续。调用栈顶部的内容就会被弹出。
④如果函数有实参，那么实参是储存在返回位置之上的。
⑤如果函数有局部变量，那么局部变量被储存在实参之上
⑥如果一个函数返回了一个值，这个值就回被写到调用函数栈帕的一个局部变量中，这个变量的地址（叫做值地址）储存在调用栈中。
⑦实参和返回值共同构成了被调用函数的栈帕。</p>
<h2 id="swap-函数分析"><a href="#swap-函数分析" class="headerlink" title="swap()函数分析"></a>swap()函数分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> z;</div><div class="line">	z=x;</div><div class="line">	x=y;</div><div class="line">	y=z;</div><div class="line">&#125;</div><div class="line"></div><div class="line">main()</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> a=<span class="number">1</span>;</div><div class="line">	<span class="keyword">int</span> b=<span class="number">2</span>;</div><div class="line">	swap(a,b);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,a,b);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们知道，上面的那个swap()函数是不能实现将a,b交换的功能的，当swap()函数被调用的时候，a和b的值就被复制给了实参x和y，调用栈的情况如下：<br></p>
<table>
    <tr>
        <td>栈帕(stack)
        </td><td>标识符(identifier)
        </td><td>地址(address)
        </td><td>值(value)
    </td></tr>
    <tr>
        <td rowspan="4">swap
        </td><td>z
        </td><td>106
        </td><td>-(未知值)
    </td></tr>
    <tr>
        <td>y
        </td><td>105
        </td><td>2
    </td></tr>
    <tr>
        <td>x
        </td><td>104
        </td><td>1
    </td></tr>
        <td>返回位置
        </td><td>103
        </td><td>第15行
    
    </td><tr>
        <td rowspan="2">main
        </td><td>b
        </td><td>102
        </td><td>2
    </td></tr>
    <tr>
        <td>a
        </td><td>101
        </td><td>1
        </td></tr>
    
</table>

<p>x的值被储存在临时变量z中，之后y的值被赋值给x，z的值赋给了y，这三步之后，在swap()函数内x和y的值确实交换了，但是在swap()中第7行代码结束之后，并在栈帕出
栈之前，栈内存是这样的：<br></p>
<table>
    <tr>
        <td>栈帕(stack)
        </td><td>标识符(identifier)
        </td><td>地址(address)
        </td><td>值(value)
    </td></tr>
    <tr>
        <td rowspan="4">swap
        </td><td>z
        </td><td>106
        </td><td>1
    </td></tr>
    <tr>
        <td>y
        </td><td>105
        </td><td>2
    </td></tr>
    <tr>
        <td>x
        </td><td>104
        </td><td>1
    </td></tr>
        <td>返回位置
        </td><td>103
        </td><td>第15行
    
    </td><tr>
        <td rowspan="2">main
        </td><td>b
        </td><td>102
        </td><td>2
    </td></tr>
    <tr>
        <td>a
        </td><td>101
        </td><td>1
        </td></tr>
    
</table>

<p>当swap()函数结束之后，顶帕出栈，栈内存就变成了：<br></p>
<table>
    <tr>
        <td>栈帕(stack)
        </td><td>标识符(identifier)
        </td><td>地址(address)
        </td><td>值(value)
    </td></tr>
    <tr>
        <td rowspan="2">main
        </td><td>b
        </td><td>102
        </td><td>2
    </td></tr>
    <tr>
        <td>a
        </td><td>101
        </td><td>1
        </td></tr>
    
</table>

<p>swap()函数被调用完成，由上面的栈内存可以看出，a和b的值并没有改变。swap()函数并没有在main()函数中起作用。C语言程序在
调用函数时使用“按值调用”的方式，这意味着值是从调用函数复制到被调用函数的实参中，这也是C语言函数调用的唯一方式。为此，C语言通过创建指针的概念来解决这个问题。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[寄存器与指令]]></title>
      <url>/2017/10/19/%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E6%8C%87%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>最近看汇编语言，顺便整理一下学了的指令以及寄存器，后面会逐步整理整理完善<br></p>
<h1 id="寄存器-register"><a href="#寄存器-register" class="headerlink" title="寄存器(register)"></a>寄存器(register)</h1><h2 id="通用寄存器-General-Purpose-Registers-8个"><a href="#通用寄存器-General-Purpose-Registers-8个" class="headerlink" title="通用寄存器(General Purpose Registers,8个)"></a>通用寄存器(General Purpose Registers,8个)</h2><p>通用寄存器是一种通用型寄存器，用于传送和暂存数据，也可以参与算术逻辑运算，并保存运算结果。
<br></p>
<p><style>
    table th:first-of-type{
        width: 100px;
        }
</style></p>
<p><table>
    <thead>
    <tr>
        <th colspan="2">寄存器</th>
        <th>功能</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>16位
        </td><td>32位
    </td></tr>
    <tr>
        <td>AX
        </td><td>EAX
        <th>累加器</th>
    </td></tr>
    <tr>
        <td>BX
        </td><td>EBX
        <th>sdfa</th>
    </td></tr>
    <tr>
        <td>CX
        <th>ECX</th>
        </td><td>
    </td></tr>
    <tr>
        <td>DX
        <th>EDX</th>
        </td><td>
    </td></tr>
    <tr>
        <td>
        <th>EBP</th>
        </td><td>
    </td></tr>
    <tr>
        <td></td>
        <th>ESP</th>
        <td>
    </td></tr>
    <tr>
        <td></td>
        <th>ESI</th>
        <td>
    </td></tr>
    <tr>
        <td></td>
        <th>EDI</th>
        <td>
    </td></tr>
    </tbody>
</table><br></p>
<h2 id="段寄存器-Segment-Registers-16位，6个"><a href="#段寄存器-Segment-Registers-16位，6个" class="headerlink" title="段寄存器(Segment Registers,16位，6个)"></a>段寄存器(Segment Registers,16位，6个)</h2><p><table>
    <thead>
    <tr>
        <th>寄存器</th>
        <th>功能</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <th>CS</th>
        <th>代码段寄存器</th>
    </tr>
    <tr>
        <td>DS
        <th>数据段寄存器</th>
    </td></tr>
    <tr>
        <th>SS</th>
        <th>栈段寄存器</th>
    </tr>
    <tr>
        <th>ES</th>
        <td>附加（数据）段寄存器
    </td></tr>
    <tr>
        <th>FS</th>
        <td>数据段寄存器
    </td></tr>
    <tr>
        <td>GS
        </td><td>数据段寄存器
    </td></tr>
    </tbody>
</table><br></p>
<h2 id="程序状态与控制寄存器-Program-Status-and-Control-Registers-32位，1个"><a href="#程序状态与控制寄存器-Program-Status-and-Control-Registers-32位，1个" class="headerlink" title="程序状态与控制寄存器(Program Status and Control Registers,32位，1个)"></a>程序状态与控制寄存器(Program Status and Control Registers,32位，1个)</h2><h3 id="EFLAGS-标志位寄存器"><a href="#EFLAGS-标志位寄存器" class="headerlink" title="EFLAGS:标志位寄存器"></a>EFLAGS:标志位寄存器</h3><p>EFLAGS是32位的寄存器，该寄存器的每位都有意义，每位的值为0或1代表On/Off或True/False,其中有些位由系统直接设定，有些位则
根据程序指令的执行结果来设定</p>
<h2 id="指令指针寄存器-Instruction-Pointer-32位，1个"><a href="#指令指针寄存器-Instruction-Pointer-32位，1个" class="headerlink" title="指令指针寄存器(Instruction Pointer,32位，1个)"></a>指令指针寄存器(Instruction Pointer,32位，1个)</h2><h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><p><table>
    <thead>
    <tr>
        <th>指令(instruction)</th>
        <th>功能</th>
    </tr>
    </thead>
    
        <tr>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th></th>
            <th></th>
        </tr>
    
</table></p>
<p>更多内容请参考Intel开发者手册：<br>
<a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf" target="_blank" rel="noopener">https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf</a></p>
]]></content>
      
        
        <tags>
            
            <tag> assembly(汇编） </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux]]></title>
      <url>/2017/10/14/linux/</url>
      <content type="html"><![CDATA[<p>##</p>
<h2 id="Directories-Found-On-Linux-Systems"><a href="#Directories-Found-On-Linux-Systems" class="headerlink" title="Directories Found On Linux Systems"></a>Directories Found On Linux Systems</h2><table>
<thead>
<tr>
<th>Directory</th>
<th>Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td>/</td>
<td>The root directory. Where everything begins.</td>
</tr>
<tr>
<td>/bin</td>
<td>Contains binaries (programs) that must be present for the system to boot and run.</td>
</tr>
<tr>
<td>/boot</td>
<td>Contains the Linux kernel, initial RAM disk image (for drivers needed at boot time), and the boot loader.Interesting files:<br>    ● /boot/grub/grub.conf or menu.lst, which<br>are used to configure the boot loader.<br>    ● /boot/vmlinuz (or something similar), the Linux kernel</td>
</tr>
<tr>
<td>/dev</td>
<td>This is a special directory which contains device nodes.“Everything is a file” also applies to devices. Here is where the kernel maintains a list of all the devices it understands.</td>
</tr>
<tr>
<td>/etc</td>
<td>The /etc directory contains all of the system-wide configuration files. It also contains a collection of shell scripts which start each of the system services at boot time.Everything in this directory should be readable text.Interesting files: While everything in /etc is interesting,here are some all-time favorites:<br>● /etc/crontab, a file that defines when automated jobs will run.<br>● /etc/fstab, a table of storage devices and their associated mount points.<br>● /etc/passwd, a list of the user accounts.</td>
</tr>
<tr>
<td>/home</td>
<td>In normal configurations, each user is given a directory in /home. Ordinary users can only write files in their home directories. This limitation protects the system from errant user activity.</td>
</tr>
<tr>
<td>/lib</td>
<td>Contains shared library files used by the core system programs. These are similar to DLLs in Windows.</td>
</tr>
<tr>
<td>/lost+found</td>
<td>Each formatted partition or device using a Linux file system,such as ext3, will have this directory. It is used in the case of a partial recovery from a file system corruption event.Unless something really bad has happened to your system,this directory will remain empty.</td>
</tr>
<tr>
<td>/media</td>
<td>On modern Linux systems the /media directory will contain the mount points for removable media such as USB drives, CD-ROMs, etc. that are mounted automatically at insertion.</td>
</tr>
<tr>
<td>/mnt</td>
<td>On older Linux systems, the /mnt directory contains mount points for removable devices that have been mounted manually.</td>
</tr>
<tr>
<td>/opt</td>
<td>The /opt directory is used to install “optional” software.This is mainly used to hold commercial software products that may be installed on your system.</td>
</tr>
<tr>
<td>/proc</td>
<td>The /proc directory is special. It’s not a real file system in the sense of files stored on your hard drive. Rather, it is a virtual file system maintained by the Linux kernel. The “files” it contains are peepholes into the kernel itself. The files are readable and will give you a picture of how the kernel sees your computer.</td>
</tr>
<tr>
<td>/root</td>
<td>This is the home directory for the root account.</td>
</tr>
<tr>
<td>/sbin</td>
<td>This directory contains “system” binaries. These are programs that perform vital system tasks that are generally reserved for the superuser.</td>
</tr>
<tr>
<td>/tmp</td>
<td>The /tmp directory is intended for storage of temporary,transient files created by various programs. Some configurations cause this directory to be emptied each time the system is rebooted.</td>
</tr>
<tr>
<td>/usr</td>
<td>The /usr directory tree is likely the largest one on a Linux system. It contains all the programs and support files used by regular users.</td>
</tr>
<tr>
<td>/usr/bin</td>
<td>/usr/bin contains the executable programs installed by your Linux distribution. It is not uncommon for this directory to hold thousands of programs./usr/lib The shared libraries for the programs in /usr/bin.</td>
</tr>
<tr>
<td>/usr/local</td>
<td>The /usr/local tree is where programs that are not included with your distribution but are intended for system-wide use are installed. Programs compiled from source code are normally installed in /usr/local/bin. On a newly installed Linux system, this tree exists, but it will be empty until the system administrator puts something in it.</td>
</tr>
<tr>
<td>/usr/sbin</td>
<td>Contains more system administration programs.</td>
</tr>
<tr>
<td>/usr/share</td>
<td>/usr/share contains all the shared data used by programs in /usr/bin. This includes things like default configuration files, icons, screen backgrounds, sound files,etc.</td>
</tr>
<tr>
<td>/usr/share/doc</td>
<td>Most packages installed on the system will include some kind of documentation. In /usr/share/doc, we will find documentation files organized by package.</td>
</tr>
<tr>
<td>/var</td>
<td>With the exception of /tmp and /home, the directories we have looked at so far remain relatively static, that is, their contents don’t change. The /var directory tree is where data that is likely to change is stored. Various databases,spool files, user mail, etc. are located here.</td>
</tr>
<tr>
<td>/var/log</td>
<td>/var/log contains log files, records of various system activity. These are very important and should be monitored from time to time. The most useful ones are /var/log/messages and/or /var/log/syslog.Note that for security reasons on some systems, you must be the superuser to view log files.</td>
</tr>
</tbody>
</table>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[hello world]]></title>
      <url>/2017/08/05/hello-world/</url>
      <content type="html"><![CDATA[<center><p>I’m new here.This is my first article.</p></center>]]></content>
      
        
    </entry>
    
  
  
</search>
