<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[利用vps搭建ss服务器]]></title>
    <url>%2F2018%2F02%2F22%2F%E5%88%A9%E7%94%A8vps%E6%90%AD%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[参考别人的文件发现搭建一个ss（shadowsocks）服务器是很简单的，利用vps（virtual private server）就可以，此文以 vultr的vps为例: 注册账号，然后充值（支持支付宝） 然后点击Servers，再点击图片中的加号添加服务器 之后就是登录服务器部署，登录之前先从server details看一看登录服务器要用到的用户名、密码以及ip地址，可以从view console登录服务器，也可以使用 Putty登录 登录服务器之后运行以下三条命令 123wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.shchmod +x shadowsocks.sh./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 三条命令运行成功之后，按照提示设置密码、端口和选择加密方式，成功安装之后会显示你的配置信息，之后下载客户端，输入配置信息就可以使用啦 相关链接： link for downloading shadowsocks 参考： https://www.jianshu.com/p/1c82ee1293a4 https://teddysun.com/342.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建博客中出现的问题以及解决方法]]></title>
    <url>%2F2017%2F12%2F20%2Fhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[hexo对html的table标签不兼容写文章时使用html的table做表格会发现文章被渲染出多个&lt;br&gt;,导致表格与其前面有很多空白的地方，十分不美观， 解决方法： 在hexo目录下_config.yml添加 123marked: gfm: true break: false 参考]]></content>
  </entry>
  <entry>
    <title><![CDATA[爬虫学习]]></title>
    <url>%2F2017%2F12%2F19%2F%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Python2.X和Python3.X调用urllib库常见的变化 Python2.X Python3.X import urllib2 import urllib.request,urllib.error import urllib import urllib.request,urllib.error,urllib.parse import urlparse import urllib.parse urllib2.open urllib.request.open urllib.urlencode urllib.parse.urlencode urllib.quote urllib.request.quote cookielib.CookieJar http.CookieJar urllib2.Request urllib.request.Request 修改报头当网站网页禁止（403 forbidden）使用Python urllib库中默认的报头(headers)，我们需要修改报头 使用build_opener()修改报头以下是实现这种方法的一段代码： 123456import urllib.requesturl = ("a url")headers = ("User-Agent","the details of User-Agent")opener = urllib.request.build_opener()opener.addheaders = [headers]data = opener.open(url).read() 使用add_header()添加报头使用urllib.request.Request()下的add_header()修改UA。 实现浏览器的模拟， 以下是实现这种方法的一段代码： 12345import urllib.requesturl = "a url"req = urllib.request.Request(url)req.add_header("User-Agent","the details of User-Agent")data = urllib.request.urlopen(req).read() 使用代理有时使用同一个IP爬取别人网页的东西，久了之后有可能会被该网站屏蔽这个IP，这是可以使用代理IP。 代理IP可以通过搜索引擎找到（国内高匿IP）。代码实现如下： 12345678910def use_proxy(proxy_addr,url): #定义一个使用代理IP的函数 import urllib.request proxy = urllib.request.ProxyHandler(&#123;'http':proxy_addr&#125;) opener = urllib.request.build_opener(proxy,urllib.request.ProxyHandler) urllib.request.install_opener(opener) data = urllib.request.urlopen(url).read().decode('utf-8') return dataproxy_addr = "xxx.xxx.xxx.xxx:xx" #这里赋值给proxy_addr的是代理的IP以及它的端口号data = use_proxy(proxy_addr,'http://www.baidu.com')print(len(data)) 这段代码运行成功会打印出百度首页的长度，失败的话会出现urllib.error.URLError的报错 正则表达式相关文档 re.search()与re.match()的qubiere.match()函数从源字符串的开头进行匹配，re.search()函数在全文进行检索并匹配 例子： 1234567891011import restring = "hellopythonmypythonhispythonourpythonPython"pattern = ".python."result1 = re.match(pattern,string)result2 = re.search(pattern,string)print(result1)print(result2)----------------------------------------#程序运行的结果为：None&lt;_sre.SRE_Match object; span(6,14),match='ypythonh'&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[函数与栈]]></title>
    <url>%2F2017%2F12%2F04%2F%E5%87%BD%E6%95%B0%E4%B8%8E%E6%A0%88%2F</url>
    <content type="text"><![CDATA[程序使用栈内存来记住函数返回的位置，每一个c程序都由栈控制其函数执行的流程。几乎所有计算机编程语言都采用这个方案。 栈的调用规则①当一个函数被调用时，这条调用之后的行编号就被压入调用栈。这个行编号就是“返回位置”（RL），这是在调用函数结束后（即返回）之后程序继续执行的地方。 ②如果相同的函数在不同行被调用，那么这个调用都有一个相应的返回位置（每个函数调用之后的那行）。 ③当一个函数结束之后，程序将从储存在调用栈顶部的行编号处继续。调用栈顶部的内容就会被弹出。 ④如果函数有实参，那么实参是储存在返回位置之上的。 ⑤如果函数有局部变量，那么局部变量被储存在实参之上 ⑥如果一个函数返回了一个值，这个值就回被写到调用函数栈帕的一个局部变量中，这个变量的地址（叫做值地址）储存在调用栈中。 ⑦实参和返回值共同构成了被调用函数的栈帕。 swap()函数分析1234567891011121314151617void swap(int x,int y)&#123; int z; z=x; x=y; y=z;&#125;main()&#123; int a=1; int b=2; swap(a,b); printf("%d %d\n",a,b); return 0;&#125; 我们知道，上面的那个swap()函数是不能实现将a,b交换的功能的，当swap()函数被调用的时候，a和b的值就被复制给了实参x和y，调用栈的情况如下： 栈帕(stack) 标识符(identifier) 地址(address) 值(value) swap z 106 -(未知值) y 105 2 x 104 1 返回位置 103 第15行 main b 102 2 a 101 1 x的值被储存在临时变量z中，之后y的值被赋值给x，z的值赋给了y，这三步之后，在swap()函数内x和y的值确实交换了，但是在swap()中第7行代码结束之后，并在栈帕出 栈之前，栈内存是这样的： 栈帕(stack) 标识符(identifier) 地址(address) 值(value) swap z 106 1 y 105 2 x 104 1 返回位置 103 第15行 main b 102 2 a 101 1 当swap()函数结束之后，顶帕出栈，栈内存就变成了： 栈帕(stack) 标识符(identifier) 地址(address) 值(value) main b 102 2 a 101 1 swap()函数被调用完成，由上面的栈内存可以看出，a和b的值并没有改变。swap()函数并没有在main()函数中起作用。C语言程序在 调用函数时使用“按值调用”的方式，这意味着值是从调用函数复制到被调用函数的实参中，这也是C语言函数调用的唯一方式。为此，C语言通过创建指针的概念来解决这个问题。]]></content>
  </entry>
  <entry>
    <title><![CDATA[寄存器与指令]]></title>
    <url>%2F2017%2F10%2F19%2F%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[最近看汇编语言，顺便整理一下学了的指令以及寄存器，后面会逐步整理整理完善 寄存器(register) table th:first-of-type{ width: 100px; } 寄存器 作用 AX BX BX BX BX BX BX BX BX BX BX BX BX BX BX BX BX BX BX BX BX BX BX BX]]></content>
      <tags>
        <tag>assembly(汇编）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数电中的等式证明]]></title>
    <url>%2F2017%2F10%2F16%2F%E6%95%B0%E7%94%B5%E4%B8%AD%E7%9A%84%E7%AD%89%E5%BC%8F%E8%AF%81%E6%98%8E%2F</url>
    <content type="text"><![CDATA[在孙万蓉主编的《数字电路与系统设计》（高等教育出版社—ISBN-9787040426618）一书中43页有这样一个习题：用公式法证明 A$\oplus$B$\oplus$C$\oplus$D=(A$\oplus$B)$\odot$(A$\oplus$C)$\odot$(A$\oplus$D),下面我给出非完全公式法的证明， 用公式和结合真值表证明: A B C A$\odot$B$\odot$C A$\oplus$B$\oplus$C 0 0 0 0 0 0 0 1 1 1 0 1 0 1 1 0 1 1 0 0 1 0 0 1 1 1 0 1 0 0 1 1 0 0 0 1 1 1 1 1 先看真值表，由真值表得出三个数之间的异或等于三个数之间的同或， 即有结论： A$\odot$B$\odot$C = A$\oplus$B$\oplus$C， 因为 A$\oplus$A = 0 , A$\oplus$0 = A 所以 A$\oplus$B$\oplus$C$\oplus$D = A$\oplus$B$\oplus$C$\oplus$D$\oplus$A$\oplus$A = (A$\oplus$B)$\oplus$(A$\oplus$C)$\oplus$(A$\oplus$D) = (A$\oplus$B)$\odot$(A$\oplus$C)$\odot$(A$\oplus$D) 证毕！]]></content>
      <tags>
        <tag>数电 证明</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux]]></title>
    <url>%2F2017%2F10%2F14%2Flinux%2F</url>
    <content type="text"><![CDATA[## Directories Found On Linux Systems Directory Comments / The root directory. Where everything begins. /bin Contains binaries (programs) that must be present for the system to boot and run. /boot Contains the Linux kernel, initial RAM disk image (for drivers needed at boot time), and the boot loader.Interesting files: ● /boot/grub/grub.conf or menu.lst, whichare used to configure the boot loader. ● /boot/vmlinuz (or something similar), the Linux kernel /dev This is a special directory which contains device nodes.“Everything is a file” also applies to devices. Here is where the kernel maintains a list of all the devices it understands. /etc The /etc directory contains all of the system-wide configuration files. It also contains a collection of shell scripts which start each of the system services at boot time.Everything in this directory should be readable text.Interesting files: While everything in /etc is interesting,here are some all-time favorites:● /etc/crontab, a file that defines when automated jobs will run.● /etc/fstab, a table of storage devices and their associated mount points.● /etc/passwd, a list of the user accounts. /home In normal configurations, each user is given a directory in /home. Ordinary users can only write files in their home directories. This limitation protects the system from errant user activity. /lib Contains shared library files used by the core system programs. These are similar to DLLs in Windows. /lost+found Each formatted partition or device using a Linux file system,such as ext3, will have this directory. It is used in the case of a partial recovery from a file system corruption event.Unless something really bad has happened to your system,this directory will remain empty. /media On modern Linux systems the /media directory will contain the mount points for removable media such as USB drives, CD-ROMs, etc. that are mounted automatically at insertion. /mnt On older Linux systems, the /mnt directory contains mount points for removable devices that have been mounted manually. /opt The /opt directory is used to install “optional” software.This is mainly used to hold commercial software products that may be installed on your system. /proc The /proc directory is special. It’s not a real file system in the sense of files stored on your hard drive. Rather, it is a virtual file system maintained by the Linux kernel. The “files” it contains are peepholes into the kernel itself. The files are readable and will give you a picture of how the kernel sees your computer. /root This is the home directory for the root account. /sbin This directory contains “system” binaries. These are programs that perform vital system tasks that are generally reserved for the superuser. /tmp The /tmp directory is intended for storage of temporary,transient files created by various programs. Some configurations cause this directory to be emptied each time the system is rebooted. /usr The /usr directory tree is likely the largest one on a Linux system. It contains all the programs and support files used by regular users. /usr/bin /usr/bin contains the executable programs installed by your Linux distribution. It is not uncommon for this directory to hold thousands of programs./usr/lib The shared libraries for the programs in /usr/bin. /usr/local The /usr/local tree is where programs that are not included with your distribution but are intended for system-wide use are installed. Programs compiled from source code are normally installed in /usr/local/bin. On a newly installed Linux system, this tree exists, but it will be empty until the system administrator puts something in it. /usr/sbin Contains more system administration programs. /usr/share /usr/share contains all the shared data used by programs in /usr/bin. This includes things like default configuration files, icons, screen backgrounds, sound files,etc. /usr/share/doc Most packages installed on the system will include some kind of documentation. In /usr/share/doc, we will find documentation files organized by package. /var With the exception of /tmp and /home, the directories we have looked at so far remain relatively static, that is, their contents don’t change. The /var directory tree is where data that is likely to change is stored. Various databases,spool files, user mail, etc. are located here. /var/log /var/log contains log files, records of various system activity. These are very important and should be monitored from time to time. The most useful ones are /var/log/messages and/or /var/log/syslog.Note that for security reasons on some systems, you must be the superuser to view log files.]]></content>
  </entry>
  <entry>
    <title><![CDATA[hello world]]></title>
    <url>%2F2017%2F08%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[I’m new here.This is my first article.]]></content>
  </entry>
</search>
