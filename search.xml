<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C语言格式化漏洞]]></title>
    <url>%2F2018%2F10%2F29%2FC%E8%AF%AD%E8%A8%80%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[格式化字符串漏洞实验 在线实验环境：格式化字符串漏洞实验 文章转载自：https://github.com/shiyanlou/seedlab/blob/master/formatstring.md 一、 实验描述格式化字符串漏洞是由像printf(user_input)这样的代码引起的，其中user_input是用户输入的数据，具有Set-UID root权限的这类程序在运行的时候，printf语句将会变得非常危险，因为它可能会导致下面的结果： 使得程序崩溃 任意一块内存读取数据 修改任意一块内存里的数据 最后一种结果是非常危险的，因为它允许用户修改set-UID root程序内部变量的值，从而改变这些程序的行为。 本实验将会提供一个具有格式化漏洞的程序，我们将制定一个计划来探索这些漏洞。 二、实验预备知识讲解2.1 什么是格式化字符串？1printf ("The magic number is: %d", 1911); 试观察运行以上语句，会发现字符串”The magic number is: %d”中的格式符％d被参数（1911）替换，因此输出变成了“The magic number is: 1911”。 格式化字符串大致就是这么一回事啦。 除了表示十进制数的％d，还有不少其他形式的格式符，一起来认识一下吧~ 格式符 含义 含义（英） 传 %d 十进制数（int） decimal 值 %u 无符号十进制数 (unsigned int) unsigned decimal 值 %x 十六进制数 (unsigned int) hexadecimal 值 %s 字符串 ((const) (unsigned) char *) string 引用（指针） %n %n符号以前输入的字符数量 (* int) number of bytes written so far 引用（指针） （ *%n的使用将在2.5节中做出说明） 2.2 栈与格式化字符串格式化函数的行为由格式化字符串控制，printf函数从栈上取得参数。 1printf ("a has value %d, b has value %d, c is at address: %08x\n",a, b, &amp;c); 2.3 如果参数数量不匹配会发生什么？如果只有一个不匹配会发生什么？ 1printf ("a has value %d, b has value %d, c is at address: %08x\n",a, b); 在上面的例子中格式字符串需要3个参数，但程序只提供了2个。 该程序能够通过编译么？ printf()是一个参数长度可变函数。因此，仅仅看参数数量是看不出问题的。 为了查出不匹配，编译器需要了解printf()的运行机制，然而编译器通常不做这类分析。 有些时候，格式字符串并不是一个常量字符串，它在程序运行期间生成(比如用户输入)，因此，编译器无法发现不匹配。 那么printf()函数自身能检测到不匹配么？ printf()从栈上取得参数，如果格式字符串需要3个参数，它会从栈上取3个，除非栈被标记了边界，printf()并不知道自己是否会用完提供的所有参数。 既然没有那样的边界标记。printf()会持续从栈上抓取数据，在一个参数数量不匹配的例子中，它会抓取到一些不属于该函数调用到的数据。 如果有人特意准备数据让printf抓取会发生什么呢？ 2.4 访问任意位置内存 我们需要得到一段数据的内存地址，但我们无法修改代码，供我们使用的只有格式字符串。 如果我们调用 printf(%s) 时没有指明内存地址, 那么目标地址就可以通过printf函数，在栈上的任意位置获取。printf函数维护一个初始栈指针,所以能够得到所有参数在栈中的位置 观察: 格式字符串位于栈上. 如果我们可以把目标地址编码进格式字符串，那样目标地址也会存在于栈上，在接下来的例子里，格式字符串将保存在栈上的缓冲区中。 12345678int main(int argc, char *argv[])&#123; char user_input[100]; ... ... /* other variable definitions and statements */ scanf("%s", user_input); /* getting a string from user */ printf(user_input); /* Vulnerable place */ return 0;&#125; 如果我们让printf函数得到格式字符串中的目标内存地址 (该地址也存在于栈上), 我们就可以访问该地址. 1printf ("\x10\x01\x48\x08 %x %x %x %x %s"); \x10\x01\x48\x08 是目标地址的四个字节， 在C语言中, \x10 告诉编译器将一个16进制数0x10放于当前位置（占1字节）。如果去掉前缀\x10就相当于两个ascii字符1和0了，这就不是我们所期望的结果了。 %x 导致栈指针向格式字符串的方向移动（参考1.2节） 下图解释了攻击方式，如果用户输入中包含了以下格式字符串 如图所示，我们使用四个%x来移动printf函数的栈指针到我们存储格式字符串的位置，一旦到了目标位置，我们使用％s来打印，它会打印位于地址0x10014808的内容，因为是将其作为字符串来处理，所以会一直打印到结束符为止。 user_input数组到传给printf函数参数的地址之间的栈空间不是为了printf函数准备的。但是，因为程序本身存在格式字符串漏洞，所以printf会把这段内存当作传入的参数来匹配％x。 最大的挑战就是想方设法找出printf函数栈指针(函数取参地址)到user_input数组的这一段距离是多少，这段距离决定了你需要在%s之前输入多少个%x。 2.5 在内存中写一个数字%n: 该符号前输入的字符数量会被存储到对应的参数中去 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 int i; printf ("12345%n", &amp;i);``` + 数字5（%n前的字符数量）将会被写入i 中+ 运用同样的方法在访问任意地址内存的时候，我们可以将一个数字写入指定的内存中。只要将上一小节(1.4)的%s替换成%n就能够覆盖0x10014808的内容。+ 利用这个方法，攻击者可以做以下事情: + 重写程序标识控制访问权限 + 重写栈或者函数等等的返回地址+ 然而，写入的值是由%n之前的字符数量决定的。真的有办法能够写入任意数值么？ + 用最古老的计数方式， 为了写1000，就填充1000个字符吧。 + 为了防止过长的格式字符串，我们可以使用一个宽度指定的格式指示器。(比如（%0数字x）就会左填充预期数量的0符号)### 三、 实验内容用户需要输入一段数据，数据保存在user_input数组中，程序会使用printf函数打印数据内容，并且该程序以root权限运行。更加可喜的是，这个程序存在一个格式化漏洞。让我们来看看利用这些漏洞可以搞些什么破坏。程序说明：&gt;程序内存中存在两个秘密值，我们想要知道这两个值，但发现无法通过读二进制代码的方式来获取它们（实验中为了简单起见，硬编码这些秘密值为0x44和0x55）。尽管我们不知道它们的值，但要得到它们的内存地址倒不是特别困难，因为对大多数系统而言，每次运行程序，这些内存地址基本上是不变的。实验假设我们已经知道了这些内存地址，为了达到这个目的，程序特意为我们打出了这些地址。&gt;&gt;有了这些前提以后我们需要达到以下目标：&gt;+ 找出secret[1]的值&gt;+ 修改secret[1]的值&gt;+ 修改secret[1]为期望值&gt;**注意**：因为实验环境是64位系统，所以需要使用%016llx才能读取整个字。但为了简便起见，对程序进行了修改了，使用%08x也能完成实验。有了之前预备知识的铺垫，先自己尝试一下，祝玩的愉快：）程序如下：```c/* vul_prog.c */ #include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#define SECRET1 0x44#define SECRET2 0x55int main(int argc, char *argv[])&#123; char user_input[100]; int *secret; long int_input; int a, b, c, d; /* other variables, not used here.*/ /* The secret value is stored on the heap */ secret = (int *) malloc(2*sizeof(int)); /* getting the secret */ secret[0] = SECRET1; secret[1] = SECRET2; printf("The variable secret's address is 0x%8x (on stack)\n", &amp;secret); printf("The variable secret's value is 0x%8x (on heap)\n", secret); printf("secret[0]'s address is 0x%8x (on heap)\n", &amp;secret[0]); printf("secret[1]'s address is 0x%8x (on heap)\n", &amp;secret[1]); printf("Please enter a decimal integer\n"); scanf("%d", &amp;int_input); /* getting an input from user */ printf("Please enter a string\n"); scanf("%s", user_input); /* getting a string from user */ /* Vulnerable place */ printf(user_input); printf("\n"); /* Verify whether your attack is successful */ printf("The original secrets: 0x%x -- 0x%x\n", SECRET1, SECRET2); printf("The new secrets: 0x%x -- 0x%x\n", secret[0], secret[1]); return 0;&#125; (ps： 编译时可以添加以下参数关掉栈保护。) 1gcc -z execstack -fno-stack-protector -o vul_prog vul_prog.c 一点小提示：你会发现secret[0]和secret[1]存在于malloc出的堆上，我们也知道secret的值存在于栈上，如果你想覆盖secret[0]的值,ok,它的地址就在栈上，你完全可以利用格式化字符串的漏洞来达到目的。然而尽管secret[1]就在它的兄弟0的旁边，你还是没办法从栈上获得它的地址，这对你来说构成了一个挑战，因为没有它的地址你怎么利用格式字符串读写呢。但是真的就没招了么？ 3.1 找出secret[1]的值1.首先定位int_input的位置，这样就确认了％s在格式字符串中的位置。 2.输入secret[1]的地址，记得做进制转换，同时在格式字符串中加入％s。 大功告成！U的ascii码就是55。 ####3.2 修改secret[1]的值 1.只要求修改，不要求改什么？简单！不明白%n用法的可以往前回顾一下。 大功告成x2！ 3.3 修改secret[1]为期望值1.要改成自己期望的值，咋办？填1000岂不累死？！可以用填充嘛！ 哦对了，0x3e8 = 1000。 大功告成x3！ 四、 练习在实验楼环境安步骤进行实验，并截图 您已经完成本课程的所有实验，干的漂亮！ License本课程所涉及的实验来自Syracuse SEED labs，并在此基础上为适配实验楼网站环境进行修改，修改后的实验文档仍然遵循GNU Free Documentation License。 本课程文档github链接：https://github.com/shiyanlou/seedlab 附Syracuse SEED labs版权声明： Copyright © 2014 Wenliang Du, Syracuse University. The development of this document is/was funded by the following grants from the US National Science Foundation: No. 1303306 and 1318814. Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.2 or any later version published by the Free Software Foundation. A copy of the license can be found at http://www.gnu.org/licenses/fdl.html.]]></content>
  </entry>
  <entry>
    <title><![CDATA[10年後の私へ]]></title>
    <url>%2F2018%2F10%2F19%2F10%E5%B9%B4%E5%BE%8C%E3%81%AE%E7%A7%81%E3%81%B8%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[ubuntu重置密码出现的问题]]></title>
    <url>%2F2018%2F02%2F23%2Fubuntu%E9%87%8D%E7%BD%AE%E5%AF%86%E7%A0%81%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[忘记ubuntu的密码之后，按照网上的一般方式进入recovery mode，然后选择drop to root shell prompt，但是进去之后提示Give root password for maintenance (要输入密码,可是自己就是要通过这种方式找回密码的)，网上找了许久，发现以下方法方法有效： 重启之后运行如下命令即可 相关参考: https://www.youtube.com/watch?v=ThPAWo7e8LI https://help.ubuntu.com/community/LostPassword]]></content>
  </entry>
  <entry>
    <title><![CDATA[利用vps搭建ss服务器]]></title>
    <url>%2F2018%2F02%2F22%2F%E5%88%A9%E7%94%A8vps%E6%90%AD%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[参考别人的文件发现搭建一个ss（shadowsocks）服务器是很简单的，利用vps（virtual private server）就可以，此文以 vultr的vps为例: 注册账号，然后充值（支持支付宝） 然后点击Servers，再点击图片中的加号添加服务器 之后就是登录服务器部署，登录之前先从server details看一看登录服务器要用到的用户名、密码以及ip地址，可以从view console登录服务器，也可以使用 Putty登录 登录服务器之后运行以下三条命令 123wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.shchmod +x shadowsocks.sh./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 三条命令运行成功之后，按照提示设置密码、端口和选择加密方式，成功安装之后会显示你的配置信息，之后下载客户端，输入配置信息就可以使用啦 相关链接： link for downloading shadowsocks 参考： https://www.jianshu.com/p/1c82ee1293a4 https://teddysun.com/342.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建博客中出现的问题以及解决方法]]></title>
    <url>%2F2017%2F12%2F20%2Fhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[hexo对html的table标签不兼容写文章时使用html的table做表格会发现文章被渲染出多个&lt;br&gt;,导致表格与其前面有很多空白的地方，十分不美观， 解决方法： 在hexo目录下_config.yml添加 123marked: gfm: true break: false 参考]]></content>
  </entry>
  <entry>
    <title><![CDATA[爬虫学习]]></title>
    <url>%2F2017%2F12%2F19%2F%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Python2.X和Python3.X调用urllib库常见的变化 Python2.X Python3.X import urllib2 import urllib.request,urllib.error import urllib import urllib.request,urllib.error,urllib.parse import urlparse import urllib.parse urllib2.open urllib.request.open urllib.urlencode urllib.parse.urlencode urllib.quote urllib.request.quote cookielib.CookieJar http.CookieJar urllib2.Request urllib.request.Request 修改报头当网站网页禁止（403 forbidden）使用Python urllib库中默认的报头(headers)，我们需要修改报头 使用build_opener()修改报头以下是实现这种方法的一段代码： 123456import urllib.requesturl = ("a url")headers = ("User-Agent","the details of User-Agent")opener = urllib.request.build_opener()opener.addheaders = [headers]data = opener.open(url).read() 使用add_header()添加报头使用urllib.request.Request()下的add_header()修改UA。 实现浏览器的模拟， 以下是实现这种方法的一段代码： 12345import urllib.requesturl = "a url"req = urllib.request.Request(url)req.add_header("User-Agent","the details of User-Agent")data = urllib.request.urlopen(req).read() 使用代理有时使用同一个IP爬取别人网页的东西，久了之后有可能会被该网站屏蔽这个IP，这是可以使用代理IP。 代理IP可以通过搜索引擎找到（国内高匿IP）。代码实现如下： 12345678910def use_proxy(proxy_addr,url): #定义一个使用代理IP的函数 import urllib.request proxy = urllib.request.ProxyHandler(&#123;'http':proxy_addr&#125;) opener = urllib.request.build_opener(proxy,urllib.request.ProxyHandler) urllib.request.install_opener(opener) data = urllib.request.urlopen(url).read().decode('utf-8') return dataproxy_addr = "xxx.xxx.xxx.xxx:xx" #这里赋值给proxy_addr的是代理的IP以及它的端口号data = use_proxy(proxy_addr,'http://www.baidu.com')print(len(data)) 这段代码运行成功会打印出百度首页的长度，失败的话会出现urllib.error.URLError的报错 正则表达式相关文档 re.search()与re.match()的qubiere.match()函数从源字符串的开头进行匹配，re.search()函数在全文进行检索并匹配 例子： 1234567891011import restring = "hellopythonmypythonhispythonourpythonPython"pattern = ".python."result1 = re.match(pattern,string)result2 = re.search(pattern,string)print(result1)print(result2)----------------------------------------#程序运行的结果为：None&lt;_sre.SRE_Match object; span(6,14),match='ypythonh'&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[函数与栈]]></title>
    <url>%2F2017%2F12%2F04%2F%E5%87%BD%E6%95%B0%E4%B8%8E%E6%A0%88%2F</url>
    <content type="text"><![CDATA[程序使用栈内存来记住函数返回的位置，每一个c程序都由栈控制其函数执行的流程。几乎所有计算机编程语言都采用这个方案。 栈的调用规则①当一个函数被调用时，这条调用之后的行编号就被压入调用栈。这个行编号就是“返回位置”（RL），这是在调用函数结束后（即返回）之后程序继续执行的地方。 ②如果相同的函数在不同行被调用，那么这个调用都有一个相应的返回位置（每个函数调用之后的那行）。 ③当一个函数结束之后，程序将从储存在调用栈顶部的行编号处继续。调用栈顶部的内容就会被弹出。 ④如果函数有实参，那么实参是储存在返回位置之上的。 ⑤如果函数有局部变量，那么局部变量被储存在实参之上 ⑥如果一个函数返回了一个值，这个值就回被写到调用函数栈帕的一个局部变量中，这个变量的地址（叫做值地址）储存在调用栈中。 ⑦实参和返回值共同构成了被调用函数的栈帕。 swap()函数分析1234567891011121314151617void swap(int x,int y)&#123; int z; z=x; x=y; y=z;&#125;main()&#123; int a=1; int b=2; swap(a,b); printf("%d %d\n",a,b); return 0;&#125; 我们知道，上面的那个swap()函数是不能实现将a,b交换的功能的，当swap()函数被调用的时候，a和b的值就被复制给了实参x和y，调用栈的情况如下： 栈帕(stack) 标识符(identifier) 地址(address) 值(value) swap z 106 -(未知值) y 105 2 x 104 1 返回位置 103 第15行 main b 102 2 a 101 1 x的值被储存在临时变量z中，之后y的值被赋值给x，z的值赋给了y，这三步之后，在swap()函数内x和y的值确实交换了，但是在swap()中第7行代码结束之后，并在栈帕出 栈之前，栈内存是这样的： 栈帕(stack) 标识符(identifier) 地址(address) 值(value) swap z 106 1 y 105 2 x 104 1 返回位置 103 第15行 main b 102 2 a 101 1 当swap()函数结束之后，顶帕出栈，栈内存就变成了： 栈帕(stack) 标识符(identifier) 地址(address) 值(value) main b 102 2 a 101 1 swap()函数被调用完成，由上面的栈内存可以看出，a和b的值并没有改变。swap()函数并没有在main()函数中起作用。C语言程序在 调用函数时使用“按值调用”的方式，这意味着值是从调用函数复制到被调用函数的实参中，这也是C语言函数调用的唯一方式。为此，C语言通过创建指针的概念来解决这个问题。]]></content>
  </entry>
  <entry>
    <title><![CDATA[寄存器与指令]]></title>
    <url>%2F2017%2F10%2F19%2F%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[最近看汇编语言，顺便整理一下学了的指令以及寄存器，后面会逐步整理整理完善 寄存器(register)通用寄存器(General Purpose Registers,8个)通用寄存器是一种通用型寄存器，用于传送和暂存数据，也可以参与算术逻辑运算，并保存运算结果。 table th:first-of-type{ width: 100px; } 寄存器 功能 16位 32位 AX EAX 累加器 BX EBX sdfa CX ECX DX EDX EBP ESP ESI EDI 段寄存器(Segment Registers,16位，6个) 寄存器 功能 CS 代码段寄存器 DS 数据段寄存器 SS 栈段寄存器 ES 附加（数据）段寄存器 FS 数据段寄存器 GS 数据段寄存器 程序状态与控制寄存器(Program Status and Control Registers,32位，1个)EFLAGS:标志位寄存器EFLAGS是32位的寄存器，该寄存器的每位都有意义，每位的值为0或1代表On/Off或True/False,其中有些位由系统直接设定，有些位则 根据程序指令的执行结果来设定 指令指针寄存器(Instruction Pointer,32位，1个)指令 指令(instruction) 功能 更多内容请参考Intel开发者手册： https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf]]></content>
      <tags>
        <tag>assembly(汇编）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux]]></title>
    <url>%2F2017%2F10%2F14%2Flinux%2F</url>
    <content type="text"><![CDATA[## Directories Found On Linux Systems Directory Comments / The root directory. Where everything begins. /bin Contains binaries (programs) that must be present for the system to boot and run. /boot Contains the Linux kernel, initial RAM disk image (for drivers needed at boot time), and the boot loader.Interesting files: ● /boot/grub/grub.conf or menu.lst, whichare used to configure the boot loader. ● /boot/vmlinuz (or something similar), the Linux kernel /dev This is a special directory which contains device nodes.“Everything is a file” also applies to devices. Here is where the kernel maintains a list of all the devices it understands. /etc The /etc directory contains all of the system-wide configuration files. It also contains a collection of shell scripts which start each of the system services at boot time.Everything in this directory should be readable text.Interesting files: While everything in /etc is interesting,here are some all-time favorites:● /etc/crontab, a file that defines when automated jobs will run.● /etc/fstab, a table of storage devices and their associated mount points.● /etc/passwd, a list of the user accounts. /home In normal configurations, each user is given a directory in /home. Ordinary users can only write files in their home directories. This limitation protects the system from errant user activity. /lib Contains shared library files used by the core system programs. These are similar to DLLs in Windows. /lost+found Each formatted partition or device using a Linux file system,such as ext3, will have this directory. It is used in the case of a partial recovery from a file system corruption event.Unless something really bad has happened to your system,this directory will remain empty. /media On modern Linux systems the /media directory will contain the mount points for removable media such as USB drives, CD-ROMs, etc. that are mounted automatically at insertion. /mnt On older Linux systems, the /mnt directory contains mount points for removable devices that have been mounted manually. /opt The /opt directory is used to install “optional” software.This is mainly used to hold commercial software products that may be installed on your system. /proc The /proc directory is special. It’s not a real file system in the sense of files stored on your hard drive. Rather, it is a virtual file system maintained by the Linux kernel. The “files” it contains are peepholes into the kernel itself. The files are readable and will give you a picture of how the kernel sees your computer. /root This is the home directory for the root account. /sbin This directory contains “system” binaries. These are programs that perform vital system tasks that are generally reserved for the superuser. /tmp The /tmp directory is intended for storage of temporary,transient files created by various programs. Some configurations cause this directory to be emptied each time the system is rebooted. /usr The /usr directory tree is likely the largest one on a Linux system. It contains all the programs and support files used by regular users. /usr/bin /usr/bin contains the executable programs installed by your Linux distribution. It is not uncommon for this directory to hold thousands of programs./usr/lib The shared libraries for the programs in /usr/bin. /usr/local The /usr/local tree is where programs that are not included with your distribution but are intended for system-wide use are installed. Programs compiled from source code are normally installed in /usr/local/bin. On a newly installed Linux system, this tree exists, but it will be empty until the system administrator puts something in it. /usr/sbin Contains more system administration programs. /usr/share /usr/share contains all the shared data used by programs in /usr/bin. This includes things like default configuration files, icons, screen backgrounds, sound files,etc. /usr/share/doc Most packages installed on the system will include some kind of documentation. In /usr/share/doc, we will find documentation files organized by package. /var With the exception of /tmp and /home, the directories we have looked at so far remain relatively static, that is, their contents don’t change. The /var directory tree is where data that is likely to change is stored. Various databases,spool files, user mail, etc. are located here. /var/log /var/log contains log files, records of various system activity. These are very important and should be monitored from time to time. The most useful ones are /var/log/messages and/or /var/log/syslog.Note that for security reasons on some systems, you must be the superuser to view log files.]]></content>
  </entry>
  <entry>
    <title><![CDATA[hello world]]></title>
    <url>%2F2017%2F08%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[I’m new here.This is my first article.]]></content>
  </entry>
</search>
